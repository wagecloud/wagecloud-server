// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vm.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVMs = `-- name: CountVMs :one
SELECT COUNT(id)
FROM vm
WHERE (
  (account_id = $1 OR $1 IS NULL) AND
  (network_id = $2 OR $2 IS NULL) AND
  (os_id = $3 OR $3 IS NULL) AND
  (arch_id = $4 OR $4 IS NULL) AND
  (name ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
  (cpu >= $6 OR $6 IS NULL) AND
  (cpu <= $7 OR $7 IS NULL) AND
  (ram >= $8 OR $8 IS NULL) AND
  (ram <= $9 OR $9 IS NULL) AND
  (storage >= $10 OR $10 IS NULL) AND
  (storage <= $11 OR $11 IS NULL) AND
  (created_at >= $12 OR $12 IS NULL) AND
  (created_at <= $13 OR $13 IS NULL)
)
`

type CountVMsParams struct {
	AccountID     pgtype.Int8
	NetworkID     pgtype.Text
	OsID          pgtype.Text
	ArchID        pgtype.Text
	Name          pgtype.Text
	CpuFrom       pgtype.Int4
	CpuTo         pgtype.Int4
	RamFrom       pgtype.Int4
	RamTo         pgtype.Int4
	StorageFrom   pgtype.Int4
	StorageTo     pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
}

func (q *Queries) CountVMs(ctx context.Context, arg CountVMsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVMs,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.CpuFrom,
		arg.CpuTo,
		arg.RamFrom,
		arg.RamTo,
		arg.StorageFrom,
		arg.StorageTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVM = `-- name: CreateVM :one
INSERT INTO vm (account_id, network_id, os_id, arch_id, name, cpu, ram, storage)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, account_id, network_id, os_id, arch_id, name, cpu, ram, storage, created_at, updated_at
`

type CreateVMParams struct {
	AccountID int64
	NetworkID string
	OsID      string
	ArchID    string
	Name      string
	Cpu       int32
	Ram       int32
	Storage   int32
}

func (q *Queries) CreateVM(ctx context.Context, arg CreateVMParams) (Vm, error) {
	row := q.db.QueryRow(ctx, createVM,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.Cpu,
		arg.Ram,
		arg.Storage,
	)
	var i Vm
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVM = `-- name: DeleteVM :exec
DELETE FROM vm
WHERE (
  id = $1 AND 
  (account_id = $2 OR $2 IS NULL)
)
`

type DeleteVMParams struct {
	ID        int64
	AccountID pgtype.Int8
}

func (q *Queries) DeleteVM(ctx context.Context, arg DeleteVMParams) error {
	_, err := q.db.Exec(ctx, deleteVM, arg.ID, arg.AccountID)
	return err
}

const getVM = `-- name: GetVM :one
SELECT vm.id, vm.account_id, vm.network_id, vm.os_id, vm.arch_id, vm.name, vm.cpu, vm.ram, vm.storage, vm.created_at, vm.updated_at
FROM vm
WHERE (
  id = $1 AND 
  (account_id = $2 OR $2 IS NULL)
)
`

type GetVMParams struct {
	ID        int64
	AccountID pgtype.Int8
}

func (q *Queries) GetVM(ctx context.Context, arg GetVMParams) (Vm, error) {
	row := q.db.QueryRow(ctx, getVM, arg.ID, arg.AccountID)
	var i Vm
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVMs = `-- name: ListVMs :many
SELECT vm.id, vm.account_id, vm.network_id, vm.os_id, vm.arch_id, vm.name, vm.cpu, vm.ram, vm.storage, vm.created_at, vm.updated_at
FROM vm
WHERE (
  (account_id = $1 OR $1 IS NULL) AND
  (network_id = $2 OR $2 IS NULL) AND
  (os_id = $3 OR $3 IS NULL) AND
  (arch_id = $4 OR $4 IS NULL) AND
  (name ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
  (cpu >= $6 OR $6 IS NULL) AND
  (cpu <= $7 OR $7 IS NULL) AND
  (ram >= $8 OR $8 IS NULL) AND
  (ram <= $9 OR $9 IS NULL) AND
  (storage >= $10 OR $10 IS NULL) AND
  (storage <= $11 OR $11 IS NULL) AND
  (created_at >= $12 OR $12 IS NULL) AND
  (created_at <= $13 OR $13 IS NULL)
)
ORDER BY created_at DESC
LIMIT $15
OFFSET $14
`

type ListVMsParams struct {
	AccountID     pgtype.Int8
	NetworkID     pgtype.Text
	OsID          pgtype.Text
	ArchID        pgtype.Text
	Name          pgtype.Text
	CpuFrom       pgtype.Int4
	CpuTo         pgtype.Int4
	RamFrom       pgtype.Int4
	RamTo         pgtype.Int4
	StorageFrom   pgtype.Int4
	StorageTo     pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) ListVMs(ctx context.Context, arg ListVMsParams) ([]Vm, error) {
	rows, err := q.db.Query(ctx, listVMs,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.CpuFrom,
		arg.CpuTo,
		arg.RamFrom,
		arg.RamTo,
		arg.StorageFrom,
		arg.StorageTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vm
	for rows.Next() {
		var i Vm
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.NetworkID,
			&i.OsID,
			&i.ArchID,
			&i.Name,
			&i.Cpu,
			&i.Ram,
			&i.Storage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVM = `-- name: UpdateVM :one
UPDATE vm
SET 
  account_id = COALESCE($2, account_id),
  network_id = COALESCE($3, network_id),
  os_id = COALESCE($4, os_id),
  arch_id = COALESCE($5, arch_id),
  name = COALESCE($6, name),
  cpu = COALESCE($7, cpu),
  ram = COALESCE($8, ram),
  storage = COALESCE($9, storage)
WHERE (
  id = $1 AND
  (account_id = $2 OR $2 IS NULL)
)
RETURNING id, account_id, network_id, os_id, arch_id, name, cpu, ram, storage, created_at, updated_at
`

type UpdateVMParams struct {
	ID        int64
	AccountID pgtype.Int8
	NetworkID pgtype.Text
	OsID      pgtype.Text
	ArchID    pgtype.Text
	Name      pgtype.Text
	Cpu       pgtype.Int4
	Ram       pgtype.Int4
	Storage   pgtype.Int4
}

func (q *Queries) UpdateVM(ctx context.Context, arg UpdateVMParams) (Vm, error) {
	row := q.db.QueryRow(ctx, updateVM,
		arg.ID,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.Cpu,
		arg.Ram,
		arg.Storage,
	)
	var i Vm
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
