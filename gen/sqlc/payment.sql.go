// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: payment.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPayments = `-- name: CountPayments :one
SELECT COUNT(id)
FROM "payment"."base"
WHERE (
  (id ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
  (account_id = $2 OR $2 IS NULL) AND
  (method = $3 OR $3 IS NULL) AND
  (status = $4 OR $4 IS NULL) AND
  (date_created >= $5 OR $5 IS NULL) AND
  (date_created <= $6 OR $6 IS NULL)
)
`

type CountPaymentsParams struct {
	ID              pgtype.Text
	AccountID       pgtype.Int8
	Method          NullPaymentMethod
	Status          NullPaymentStatus
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
}

func (q *Queries) CountPayments(ctx context.Context, arg CountPaymentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPayments,
		arg.ID,
		arg.AccountID,
		arg.Method,
		arg.Status,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO "payment"."base" (account_id, method, status, total)
VALUES ($1, $2, $3, $4)
RETURNING id, account_id, method, status, total, date_created
`

type CreatePaymentParams struct {
	AccountID int64
	Method    PaymentMethod
	Status    PaymentStatus
	Total     int64
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.AccountID,
		arg.Method,
		arg.Status,
		arg.Total,
	)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Method,
		&i.Status,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

const createPaymentItem = `-- name: CreatePaymentItem :one
INSERT INTO "payment"."item" (payment_id, name, price)
VALUES ($1, $2, $3)
RETURNING id, payment_id, name, price
`

type CreatePaymentItemParams struct {
	PaymentID int64
	Name      string
	Price     int64
}

func (q *Queries) CreatePaymentItem(ctx context.Context, arg CreatePaymentItemParams) (PaymentItem, error) {
	row := q.db.QueryRow(ctx, createPaymentItem, arg.PaymentID, arg.Name, arg.Price)
	var i PaymentItem
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Name,
		&i.Price,
	)
	return i, err
}

const createPaymentVnpay = `-- name: CreatePaymentVnpay :one
INSERT INTO "payment"."vnpay" (id, "vnp_TxnRef", "vnp_OrderInfo", "vnp_TransactionNo", "vnp_TransactionDate", "vnp_CreateDate", "vnp_IpAddr")
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, "vnp_TxnRef", "vnp_OrderInfo", "vnp_TransactionNo", "vnp_TransactionDate", "vnp_CreateDate", "vnp_IpAddr"
`

type CreatePaymentVnpayParams struct {
	ID                 int64
	VnpTxnRef          string
	VnpOrderInfo       string
	VnpTransactionNo   string
	VnpTransactionDate string
	VnpCreateDate      string
	VnpIpAddr          string
}

func (q *Queries) CreatePaymentVnpay(ctx context.Context, arg CreatePaymentVnpayParams) (PaymentVnpay, error) {
	row := q.db.QueryRow(ctx, createPaymentVnpay,
		arg.ID,
		arg.VnpTxnRef,
		arg.VnpOrderInfo,
		arg.VnpTransactionNo,
		arg.VnpTransactionDate,
		arg.VnpCreateDate,
		arg.VnpIpAddr,
	)
	var i PaymentVnpay
	err := row.Scan(
		&i.ID,
		&i.VnpTxnRef,
		&i.VnpOrderInfo,
		&i.VnpTransactionNo,
		&i.VnpTransactionDate,
		&i.VnpCreateDate,
		&i.VnpIpAddr,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM "payment"."base"
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const getPayment = `-- name: GetPayment :one
SELECT p.id, p.account_id, p.method, p.status, p.total, p.date_created
FROM "payment"."base" p
WHERE p.id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id int64) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Method,
		&i.Status,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT p.id, p.account_id, p.method, p.status, p.total, p.date_created
FROM "payment"."base" p
WHERE (
  (p.id ILIKE '%' || $1 || '%' OR $1 IS NULL) AND
  (p.account_id = $2 OR $2 IS NULL) AND
  (p.method = $3 OR $3 IS NULL) AND
  (p.status = $4 OR $4 IS NULL) AND
  (p.date_created >= $5 OR $5 IS NULL) AND
  (p.date_created <= $6 OR $6 IS NULL)
)
ORDER BY p.date_created DESC
LIMIT $8
OFFSET $7
`

type ListPaymentsParams struct {
	ID              pgtype.Text
	AccountID       pgtype.Int8
	Method          NullPaymentMethod
	Status          NullPaymentStatus
	DateCreatedFrom pgtype.Timestamptz
	DateCreatedTo   pgtype.Timestamptz
	Offset          int32
	Limit           int32
}

func (q *Queries) ListPayments(ctx context.Context, arg ListPaymentsParams) ([]PaymentBase, error) {
	rows, err := q.db.Query(ctx, listPayments,
		arg.ID,
		arg.AccountID,
		arg.Method,
		arg.Status,
		arg.DateCreatedFrom,
		arg.DateCreatedTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentBase
	for rows.Next() {
		var i PaymentBase
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Method,
			&i.Status,
			&i.Total,
			&i.DateCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE "payment"."base"
SET
    method = COALESCE($2, method),
    status = COALESCE($3, status),
    total = COALESCE($4, total)
WHERE id = $1
RETURNING id, account_id, method, status, total, date_created
`

type UpdatePaymentParams struct {
	ID     int64
	Method NullPaymentMethod
	Status NullPaymentStatus
	Total  pgtype.Int8
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (PaymentBase, error) {
	row := q.db.QueryRow(ctx, updatePayment,
		arg.ID,
		arg.Method,
		arg.Status,
		arg.Total,
	)
	var i PaymentBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Method,
		&i.Status,
		&i.Total,
		&i.DateCreated,
	)
	return i, err
}
