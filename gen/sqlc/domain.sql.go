// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: domain.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDomains = `-- name: CountDomains :one
SELECT COUNT(id)
FROM "instance"."domain"
WHERE (
  (network_id = $1 OR $1 IS NULL) AND
  (name ILIKE '%' || $2 || '%' OR $2 IS NULL)
)
`

type CountDomainsParams struct {
	NetworkID pgtype.Int8
	Name      pgtype.Text
}

func (q *Queries) CountDomains(ctx context.Context, arg CountDomainsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countDomains, arg.NetworkID, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDomain = `-- name: CreateDomain :one
INSERT INTO "instance"."domain" (network_id, name)
VALUES ($1, $2)
RETURNING id, network_id, name
`

type CreateDomainParams struct {
	NetworkID int64
	Name      string
}

func (q *Queries) CreateDomain(ctx context.Context, arg CreateDomainParams) (InstanceDomain, error) {
	row := q.db.QueryRow(ctx, createDomain, arg.NetworkID, arg.Name)
	var i InstanceDomain
	err := row.Scan(&i.ID, &i.NetworkID, &i.Name)
	return i, err
}

const deleteDomain = `-- name: DeleteDomain :exec
DELETE FROM "instance"."domain"
WHERE id = $1
`

func (q *Queries) DeleteDomain(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDomain, id)
	return err
}

const getDomain = `-- name: GetDomain :one
SELECT domain.id, domain.network_id, domain.name
FROM "instance"."domain" domain
WHERE id = $1
`

func (q *Queries) GetDomain(ctx context.Context, id int64) (InstanceDomain, error) {
	row := q.db.QueryRow(ctx, getDomain, id)
	var i InstanceDomain
	err := row.Scan(&i.ID, &i.NetworkID, &i.Name)
	return i, err
}

const listDomains = `-- name: ListDomains :many
SELECT domain.id, domain.network_id, domain.name
FROM "instance"."domain" domain
WHERE (
  (network_id = $1 OR $1 IS NULL) AND
  (name ILIKE '%' || $2 || '%' OR $2 IS NULL)
)
ORDER BY id DESC
LIMIT $4
OFFSET $3
`

type ListDomainsParams struct {
	NetworkID pgtype.Int8
	Name      pgtype.Text
	Offset    int32
	Limit     int32
}

// TODO: add order by sqlc.arg('order_by')
func (q *Queries) ListDomains(ctx context.Context, arg ListDomainsParams) ([]InstanceDomain, error) {
	rows, err := q.db.Query(ctx, listDomains,
		arg.NetworkID,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InstanceDomain
	for rows.Next() {
		var i InstanceDomain
		if err := rows.Scan(&i.ID, &i.NetworkID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDomain = `-- name: UpdateDomain :one
UPDATE "instance"."domain"
SET
    name = COALESCE($2, name)
WHERE id = $1
RETURNING id, network_id, name
`

type UpdateDomainParams struct {
	ID   int64
	Name pgtype.Text
}

func (q *Queries) UpdateDomain(ctx context.Context, arg UpdateDomainParams) (InstanceDomain, error) {
	row := q.db.QueryRow(ctx, updateDomain, arg.ID, arg.Name)
	var i InstanceDomain
	err := row.Scan(&i.ID, &i.NetworkID, &i.Name)
	return i, err
}
