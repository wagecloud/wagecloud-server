// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: instance_log.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInstanceLogs = `-- name: CountInstanceLogs :one
SELECT COUNT(id)
FROM "instance"."log"
WHERE (
  (instance_id = $1 OR $1 IS NULL) AND
  (type = $2 OR $2 IS NULL) AND
  (title ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
  (description ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
  (created_at >= $5 OR $5 IS NULL) AND
  (created_at <= $6 OR $6 IS NULL)
)
`

type CountInstanceLogsParams struct {
	InstanceID    pgtype.Text
	Type          NullInstanceLogType
	Title         pgtype.Text
	Description   pgtype.Text
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
}

func (q *Queries) CountInstanceLogs(ctx context.Context, arg CountInstanceLogsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInstanceLogs,
		arg.InstanceID,
		arg.Type,
		arg.Title,
		arg.Description,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInstanceLog = `-- name: CreateInstanceLog :one
INSERT INTO "instance"."log" (instance_id, type, title, description)
VALUES ($1, $2, $3, $4)
RETURNING id, instance_id, type, title, description, created_at
`

type CreateInstanceLogParams struct {
	InstanceID  string
	Type        InstanceLogType
	Title       string
	Description pgtype.Text
}

func (q *Queries) CreateInstanceLog(ctx context.Context, arg CreateInstanceLogParams) (InstanceLog, error) {
	row := q.db.QueryRow(ctx, createInstanceLog,
		arg.InstanceID,
		arg.Type,
		arg.Title,
		arg.Description,
	)
	var i InstanceLog
	err := row.Scan(
		&i.ID,
		&i.InstanceID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInstanceLog = `-- name: DeleteInstanceLog :exec
DELETE FROM "instance"."log"
WHERE id = $1
`

func (q *Queries) DeleteInstanceLog(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteInstanceLog, id)
	return err
}

const getInstanceLog = `-- name: GetInstanceLog :one
SELECT log.id, log.instance_id, log.type, log.title, log.description, log.created_at
FROM "instance"."log" log
WHERE id = $1
`

func (q *Queries) GetInstanceLog(ctx context.Context, id int64) (InstanceLog, error) {
	row := q.db.QueryRow(ctx, getInstanceLog, id)
	var i InstanceLog
	err := row.Scan(
		&i.ID,
		&i.InstanceID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const listInstanceLogs = `-- name: ListInstanceLogs :many
SELECT log.id, log.instance_id, log.type, log.title, log.description, log.created_at
FROM "instance"."log" log
WHERE (
  (instance_id = $1 OR $1 IS NULL) AND
  (type = $2 OR $2 IS NULL) AND
  (title ILIKE '%' || $3 || '%' OR $3 IS NULL) AND
  (description ILIKE '%' || $4 || '%' OR $4 IS NULL) AND
  (created_at >= $5 OR $5 IS NULL) AND
  (created_at <= $6 OR $6 IS NULL)
)
ORDER BY created_at DESC
LIMIT $8
OFFSET $7
`

type ListInstanceLogsParams struct {
	InstanceID    pgtype.Text
	Type          NullInstanceLogType
	Title         pgtype.Text
	Description   pgtype.Text
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) ListInstanceLogs(ctx context.Context, arg ListInstanceLogsParams) ([]InstanceLog, error) {
	rows, err := q.db.Query(ctx, listInstanceLogs,
		arg.InstanceID,
		arg.Type,
		arg.Title,
		arg.Description,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InstanceLog
	for rows.Next() {
		var i InstanceLog
		if err := rows.Scan(
			&i.ID,
			&i.InstanceID,
			&i.Type,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstanceLog = `-- name: UpdateInstanceLog :one
UPDATE "instance"."log"
SET
    instance_id = COALESCE($2, instance_id),
    type = COALESCE($3, type),
    title = COALESCE($4, title),
    description = CASE
        WHEN $5::boolean THEN NULL
        ELSE COALESCE($6, description)
    END
WHERE id = $1
RETURNING id, instance_id, type, title, description, created_at
`

type UpdateInstanceLogParams struct {
	ID              int64
	InstanceID      pgtype.Text
	Type            NullInstanceLogType
	Title           pgtype.Text
	NullDescription bool
	Description     pgtype.Text
}

func (q *Queries) UpdateInstanceLog(ctx context.Context, arg UpdateInstanceLogParams) (InstanceLog, error) {
	row := q.db.QueryRow(ctx, updateInstanceLog,
		arg.ID,
		arg.InstanceID,
		arg.Type,
		arg.Title,
		arg.NullDescription,
		arg.Description,
	)
	var i InstanceLog
	err := row.Scan(
		&i.ID,
		&i.InstanceID,
		&i.Type,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
