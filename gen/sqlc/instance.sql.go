// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: instance.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInstances = `-- name: CountInstances :one
SELECT COUNT(id)
FROM "instance"."base"
WHERE (
  (account_id = $1 OR $1 IS NULL) AND
  (network_id = $2 OR $2 IS NULL) AND
  (os_id = $3 OR $3 IS NULL) AND
  (arch_id = $4 OR $4 IS NULL) AND
  (name ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
  (cpu >= $6 OR $6 IS NULL) AND
  (cpu <= $7 OR $7 IS NULL) AND
  (ram >= $8 OR $8 IS NULL) AND
  (ram <= $9 OR $9 IS NULL) AND
  (storage >= $10 OR $10 IS NULL) AND
  (storage <= $11 OR $11 IS NULL) AND
  (created_at >= $12 OR $12 IS NULL) AND
  (created_at <= $13 OR $13 IS NULL)
)
`

type CountInstancesParams struct {
	AccountID     pgtype.Int8
	NetworkID     pgtype.Text
	OsID          pgtype.Text
	ArchID        pgtype.Text
	Name          pgtype.Text
	CpuFrom       pgtype.Int4
	CpuTo         pgtype.Int4
	RamFrom       pgtype.Int4
	RamTo         pgtype.Int4
	StorageFrom   pgtype.Int4
	StorageTo     pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
}

func (q *Queries) CountInstances(ctx context.Context, arg CountInstancesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInstances,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.CpuFrom,
		arg.CpuTo,
		arg.RamFrom,
		arg.RamTo,
		arg.StorageFrom,
		arg.StorageTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInstance = `-- name: CreateInstance :one
INSERT INTO "instance"."base" (id, account_id, network_id, os_id, arch_id, name, cpu, ram, storage)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, account_id, network_id, os_id, arch_id, name, cpu, ram, storage, created_at, updated_at
`

type CreateInstanceParams struct {
	ID        string
	AccountID int64
	NetworkID string
	OsID      string
	ArchID    string
	Name      string
	Cpu       int32
	Ram       int32
	Storage   int32
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (InstanceBase, error) {
	row := q.db.QueryRow(ctx, createInstance,
		arg.ID,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.Cpu,
		arg.Ram,
		arg.Storage,
	)
	var i InstanceBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInstance = `-- name: DeleteInstance :exec
DELETE FROM "instance"."base"
WHERE (
  id = $1
)
`

func (q *Queries) DeleteInstance(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInstance, id)
	return err
}

const getInstance = `-- name: GetInstance :one
SELECT instance.id, instance.account_id, instance.network_id, instance.os_id, instance.arch_id, instance.name, instance.cpu, instance.ram, instance.storage, instance.created_at, instance.updated_at
FROM "instance"."base" instance
WHERE (
  id = $1
)
`

func (q *Queries) GetInstance(ctx context.Context, id string) (InstanceBase, error) {
	row := q.db.QueryRow(ctx, getInstance, id)
	var i InstanceBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInstances = `-- name: ListInstances :many
SELECT instance.id, instance.account_id, instance.network_id, instance.os_id, instance.arch_id, instance.name, instance.cpu, instance.ram, instance.storage, instance.created_at, instance.updated_at
FROM "instance"."base" instance
WHERE (
  (account_id = $1 OR $1 IS NULL) AND
  (network_id = $2 OR $2 IS NULL) AND
  (os_id = $3 OR $3 IS NULL) AND
  (arch_id = $4 OR $4 IS NULL) AND
  (name ILIKE '%' || $5 || '%' OR $5 IS NULL) AND
  (cpu >= $6 OR $6 IS NULL) AND
  (cpu <= $7 OR $7 IS NULL) AND
  (ram >= $8 OR $8 IS NULL) AND
  (ram <= $9 OR $9 IS NULL) AND
  (storage >= $10 OR $10 IS NULL) AND
  (storage <= $11 OR $11 IS NULL) AND
  (created_at >= $12 OR $12 IS NULL) AND
  (created_at <= $13 OR $13 IS NULL)
)
ORDER BY created_at DESC
LIMIT $15
OFFSET $14
`

type ListInstancesParams struct {
	AccountID     pgtype.Int8
	NetworkID     pgtype.Text
	OsID          pgtype.Text
	ArchID        pgtype.Text
	Name          pgtype.Text
	CpuFrom       pgtype.Int4
	CpuTo         pgtype.Int4
	RamFrom       pgtype.Int4
	RamTo         pgtype.Int4
	StorageFrom   pgtype.Int4
	StorageTo     pgtype.Int4
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
	Offset        int32
	Limit         int32
}

func (q *Queries) ListInstances(ctx context.Context, arg ListInstancesParams) ([]InstanceBase, error) {
	rows, err := q.db.Query(ctx, listInstances,
		arg.AccountID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.CpuFrom,
		arg.CpuTo,
		arg.RamFrom,
		arg.RamTo,
		arg.StorageFrom,
		arg.StorageTo,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InstanceBase
	for rows.Next() {
		var i InstanceBase
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.NetworkID,
			&i.OsID,
			&i.ArchID,
			&i.Name,
			&i.Cpu,
			&i.Ram,
			&i.Storage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstance = `-- name: UpdateInstance :one
UPDATE "instance"."base"
SET
  network_id = COALESCE($2, network_id),
  os_id = COALESCE($3, os_id),
  arch_id = COALESCE($4, arch_id),
  name = COALESCE($5, name),
  cpu = COALESCE($6, cpu),
  ram = COALESCE($7, ram),
  storage = COALESCE($8, storage)
WHERE (
  id = $1
)
RETURNING id, account_id, network_id, os_id, arch_id, name, cpu, ram, storage, created_at, updated_at
`

type UpdateInstanceParams struct {
	ID        string
	NetworkID pgtype.Text
	OsID      pgtype.Text
	ArchID    pgtype.Text
	Name      pgtype.Text
	Cpu       pgtype.Int4
	Ram       pgtype.Int4
	Storage   pgtype.Int4
}

func (q *Queries) UpdateInstance(ctx context.Context, arg UpdateInstanceParams) (InstanceBase, error) {
	row := q.db.QueryRow(ctx, updateInstance,
		arg.ID,
		arg.NetworkID,
		arg.OsID,
		arg.ArchID,
		arg.Name,
		arg.Cpu,
		arg.Ram,
		arg.Storage,
	)
	var i InstanceBase
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.NetworkID,
		&i.OsID,
		&i.ArchID,
		&i.Name,
		&i.Cpu,
		&i.Ram,
		&i.Storage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
